<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - custom attributes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
    <!-- JS dependencies -->
    <script src="./js/Three.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <!-- WEBGL mountpoint -->
    <div id="container"></div>

    <!-- Vertex shader -->
    <script type="x-shader/x-vertex" id="vertexshader">
     uniform float amplitude;
     uniform float scaleFactor;
     attribute float displacement;
     varying vec2 vUv;

     void main() {
         vUv = uv ; //( 0.5 + amplitude ) * uv + vec2( amplitude );

         vec3 newPosition = position + amplitude * normal * vec3( displacement );
         vec3 newPosition2 = mat3(
             vec3(1, 0, 0),
             vec3(0, 1, 0),
             vec3(0, 0, scaleFactor)
         ) * newPosition;

         gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition2, 1.0 );
     }
    </script>

    <!-- Fragment shader -->
    <script type="x-shader/x-fragment" id="fragmentshader">
     varying vec2 vUv;
     uniform sampler2D texture;
     void main() {
         gl_FragColor = texture2D(texture, vUv);
     }
    </script>

    <!-- JS setup code -->
    <script>
        var renderer, scene, camera, stats;
        var sphere, uniforms;
        var displacement, noise;
        var meshLengthSegments;
        var meshWidthSegments;

        init();
        animate();

        function init() {
            // Camera setup
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 30;
            camera.position.x = 5;

            // Scene setup
            scene = new THREE.Scene();

            // Shader variables setup
            uniforms = {
                amplitude: {
                    value: 10
                },
                scaleFactor: {
                    value: 1.0
                },
                texture: {
                    value: new THREE.TextureLoader().load("textures/about-us.png")
                }
            };
            uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.MirroredRepeatWrapping;
            var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent
            });

            // setting up the geometry
            meshLengthSegments = 100
            meshWidthSegments = meshLengthSegments
            meshWidth = 50
            meshLength = meshWidth
            var geometry = new THREE.PlaneBufferGeometry(meshLength, meshWidth, meshLengthSegments, meshWidthSegments);

            // Function to change uv mapping
            function change_uvs(geometry, unitx, unity, offsetx, offsety) {
                var uvs = geometry.attributes.uv.array;
                for (var i = 0; i < uvs.length; i += 2) {
                    uvs[i] = (uvs[i] + offsetx) * unitx;
                    uvs[i + 1] = (uvs[i + 1] + offsety) * unity;
                }
            }

            // Changing uv mapping of current geometry
            change_uvs(geometry, 1, 1, 0, 0)

            // Deforming plane with displacements
            var e1, e2
            displacement = new Float32Array(geometry.attributes.position.count);
            for (var i = 0; i < displacement.length; i++) {
                e1 = 0.5 * (i / meshWidthSegments)
                e2 = 0.5 * (i % meshWidthSegments)
                displacement[i] = 2 * Math.sin(e1) * Math.sin(e2);
            }

            // Setting up the shaders' attributes
            geometry.addAttribute('displacement', new THREE.BufferAttribute(displacement, 1));

            // Creating the mesh
            plane = new THREE.Mesh(geometry, shaderMaterial);

            // Adding the mesh to our scene
            scene.add(plane);

            // Rendering
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            var container = document.getElementById('container');
            container.appendChild(renderer.domElement);

            // Event listeneres
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            var time = Date.now() * 0.0001;

            // Rotating and scaling plane wrt time
            plane.rotation.z = 0.5 * time;
            uniforms.scaleFactor.value = 0 + 0.2 * Math.sin(time)

            // Render
            renderer.render(scene, camera);
        }
    </script>

</body>

</html>
